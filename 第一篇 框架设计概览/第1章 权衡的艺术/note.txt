1.命令式和声明式
命令式框架（如jQuery）更关注过程,自然语言描述能够与代码产生一一对应的关系，代码本身描述的是“做事的过程”。
$('#app')
    .text('hello world')
    .on('click', () => { alert('ok') })

声明式框架（如Vue.js）更关注结果，对于如何实现这个“结果”并不关心。
<div @click="() => alert('ok')">hello world</div>

Vue.js 帮我们封装了过程，其内部实现一定是命令式的，而暴露给用户的却更加声明式。

声明式代码的性能不优于命令式，因为声明式代码最终还是要依靠命令式代码来完成操作。但声明式代码的可维护性更强。
在框架设计上要做出可维护性和性能之间的权衡，在保持可维护性的同时让性能损失最小化。


2.虚拟DOM的性能
声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗
虚拟 DOM，就是为了最小化找出差异的性能消耗。采用虚拟 DOM 的更新技术的性能理论上不可能比原生 Javascript 操作 DOM 更高。

innerHTML 和 DOM 性能比较
innerHTML
const html = `<div>...</div>`
div.innerHTML = html
首先要把字符串解析成 DOM 树，这是一个 DOM 层面的计算，远比 Javascript 层面的计算性能差。
创建页面性能：HTML 字符串拼接的计算量 + innerHTML 的 DOM 计算量。

虚拟DOM
第一步是创建 Javascript 对象（虚拟 DOM 树），第二步是递归遍历虚拟 DOM 树创建真实 DOM。
创建页面性能：创建 Javascript 对象的计算量 + 创建真实 DOM 的计算量。

创建页面时两种方式性能差异不大。

更新页面
innerHTML 方式是重新构建 HTML 字符串，再重新设置 DOM 元素的 innerHTML 属性。
虚拟 DOM 方式是重新创建 Javascript 对象，然后笔记新旧虚拟 DOM，找到变化的元素并更新它。
虚拟 DOM 只会更新必要的元素，但 innerHTML 需要全量更新，因此虚拟 DOM 具备优势。


3.运行时和编译时
编译器帮你把源代码翻译成机器能识别的代码，编译时就是做一些简单的翻译工作
运行时就是把保存在磁盘上的代码装载到内存中
纯运行时框架：提供一个 Render 函数，将特定 Javascript 对象渲染成真实 DOM 挂载到页面上。
运行时+编译时框架：提供一个 Compiler 函数，将 HTML 字符串编译成特定数据结构，再结合 Render 函数进行渲染。
const obj = Compiler(html)
Render(obj, document.body)
准确地说，上面的代码其实是运行时编译，意思是代码运行的时候才开始编译，这会产生一定的性能开销。因此我们也可以在构建的时候就执行 Compiler 程序将用户提供的内容编译好，等到运行时就无须编译了，这对性能是非常友好的。 // 如何在构建时进行编译？
纯编译时框架：利用 Compiler 直接将 HTML 字符串编译成命令式代码。

Vue.js 3 保持了运行时 + 编译时的架构。